{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red170\green13\blue145;\red255\green255\blue255;\red0\green0\blue0;
\red92\green38\blue153;\red196\green26\blue22;\red46\green13\blue110;\red28\green0\blue207;\red38\green71\blue75;
\red63\green110\blue116;\red0\green116\blue0;}
{\*\expandedcolortbl;;\csgenericrgb\c66500\c5200\c56900;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0;
\csgenericrgb\c35900\c14900\c60100;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c18100\c5200\c43100;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c14900\c27800\c29400;
\csgenericrgb\c24700\c43100\c45600;\csgenericrgb\c0\c45600\c0;}
\margl1440\margr1440\vieww28300\viewh15020\viewkind0
\deftab890
\pard\tx890\pardeftab890\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \cb3 func
\fs36 \cf4  insert(separator: 
\fs28 \cf5 String
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf5 Int
\fs36 \cf4 , intoString: 
\fs28 \cf5 String
\fs36 \cf4 ) -> 
\fs28 \cf5 String
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 var
\fs36 \cf4  output = 
\fs28 \cf6 ""
\f1\fs24 \cf0 \

\f0\fs36 \cf4     intoString.
\fs28 \cf7 enumerated
\fs36 \cf4 ().
\fs28 \cf7 forEach
\fs36 \cf4  \{ index, c 
\fs28 \cf2 in
\f1\fs24 \cf0 \

\f0\fs36 \cf4         
\fs28 \cf2 if
\fs36 \cf4  index % afterEveryXCharacters == 
\fs28 \cf8 0
\fs36 \cf4  && index > 
\fs28 \cf8 0
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4             output += separator
\f1\fs24 \cf0 \

\f0\fs36 \cf4         \}
\f1\fs24 \cf0 \

\f0\fs36 \cf4         output.
\fs28 \cf7 append
\fs36 \cf4 (c)
\f1\fs24 \cf0 \

\f0\fs36 \cf4     \}
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 return
\fs36 \cf4  output
\f1\fs24 \cf0 \

\f0\fs36 \cf4 \}
\f1\fs24 \cf0 \
\

\f0\fs28 \cf9 insert
\fs36 \cf4 (separator: 
\fs28 \cf6 ":"
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf8 5
\fs36 \cf4 , intoString: 
\fs28 \cf6 "123456789"
\fs36 \cf4 )\
\
\
\
// Every
\fs40 thing is working:\

\fs28 \cf2 func
\fs36 \cf4  insert(separator: 
\fs28 \cf5 String
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf5 Int
\fs36 \cf4 , intoString: 
\fs28 \cf5 String
\fs36 \cf4 ) -> 
\fs28 \cf5 String
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 var
\fs36 \cf4  output = 
\fs28 \cf6 ""
\f1\fs24 \cf0 \

\f0\fs36 \cf4     intoString.
\fs28 \cf7 enumerated
\fs36 \cf4 ().
\fs28 \cf7 forEach
\fs36 \cf4  \{ index, c 
\fs28 \cf2 in
\f1\fs24 \cf0 \

\f0\fs36 \cf4         
\fs28 \cf2 if
\fs36 \cf4  index % afterEveryXCharacters == 
\fs28 \cf8 0
\fs36 \cf4  && index > 
\fs28 \cf8 0
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4             output += separator
\f1\fs24 \cf0 \

\f0\fs36 \cf4         \}
\f1\fs24 \cf0 \

\f0\fs36 \cf4         output.
\fs28 \cf7 append
\fs36 \cf4 (c)
\f1\fs24 \cf0 \

\f0\fs36 \cf4     \}
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 return
\fs36 \cf4  output
\f1\fs24 \cf0 \

\f0\fs36 \cf4 \}
\f1\fs24 \cf0 \
\

\f0\fs28 \cf9 insert
\fs36 \cf4 (separator: 
\fs28 \cf6 ":"
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf8 5
\fs36 \cf4 , intoString: 
\fs28 \cf6 "123456789"
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 var
\fs36 \cf4  stringForReverse = 
\fs28 \cf6 "Hello, World!"
\f1\fs24 \cf0 \

\f0\fs28 \cf2 let
\fs36 \cf4  reversedString = 
\fs28 \cf5 String
\fs36 \cf4 (
\fs28 \cf10 stringForReverse
\fs36 \cf4 .
\fs28 \cf7 reversed
\fs36 \cf4 ())
\f1\fs24 \cf0 \

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf10 reversedString
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 let
\fs36 \cf4  input = 
\fs28 \cf6 "1234567890123"
\f1\fs24 \cf0 \

\f0\fs28 \cf9 insert
\fs36 \cf4 (separator: 
\fs28 \cf6 " "
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf8 5
\fs36 \cf4 , intoString: 
\fs28 \cf10 input
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 let
\fs36 \cf4  reversedInput = 
\fs28 \cf5 String
\fs36 \cf4 (
\fs28 \cf10 input
\fs36 \cf4 .
\fs28 \cf7 reversed
\fs36 \cf4 ())
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 let
\fs36 \cf4  newString = 
\fs28 \cf9 insert
\fs36 \cf4 (separator: 
\fs28 \cf6 " "
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf8 5
\fs36 \cf4 , intoString: 
\fs28 \cf10 reversedInput
\fs36 \cf4 )
\f1\fs24 \cf0 \

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf6 "The new string is: 
\fs36 \cf4 \\
\fs28 \cf6 (\cf10 newString\cf6 )"
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 let
\fs36 \cf4  lastString = 
\fs28 \cf5 String
\fs36 \cf4 (
\fs28 \cf10 newString
\fs36 \cf4 .
\fs28 \cf7 reversed
\fs36 \cf4 ())
\f1\fs24 \cf0 \

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf6 "The result is : 
\fs36 \cf4 \\
\fs28 \cf6 (\cf10 lastString\cf6 )"
\fs36 \cf4 )\
\
\

\fs28 \cf2 func
\fs36 \cf4  makeInsertion(separator: 
\fs28 \cf5 String
\fs36 \cf4 , afterEveryXCharacters: 
\fs28 \cf5 Int
\fs36 \cf4 , intoString: 
\fs28 \cf5 String
\fs36 \cf4 ) -> 
\fs28 \cf5 String
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 var
\fs36 \cf4  ouput = 
\fs28 \cf6 ""
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 for
\fs36 \cf4  (index, c) 
\fs28 \cf2 in
\fs36 \cf4  intoString.
\fs28 \cf7 enumerated
\fs36 \cf4 () \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4         
\fs28 \cf2 if
\fs36 \cf4  index % afterEveryXCharacters == 
\fs28 \cf8 0
\fs36 \cf4  && index > 
\fs28 \cf8 0
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4             ouput += separator
\f1\fs24 \cf0 \

\f0\fs36 \cf4         \}
\f1\fs24 \cf0 \

\f0\fs36 \cf4         ouput.
\fs28 \cf7 append
\fs36 \cf4 (c)
\f1\fs24 \cf0 \

\f0\fs36 \cf4     \}
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf2 return
\fs36 \cf4  ouput
\f1\fs24 \cf0 \

\f0\fs36 \cf4 \}\
\
\
// Another idea\

\fs28 \cf2 var
\fs36 \cf4  userInput = 
\fs28 \cf6 "1234512345"
\f1\fs24 \cf0 \

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf6 "The input is: 
\fs36 \cf4 \\
\fs28 \cf6 (\cf10 userInput\cf6 )"
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 let
\fs36 \cf4  countSymbols = 
\fs28 \cf10 userInput
\fs36 \cf4 .
\fs28 \cf5 count
\f1\fs24 \cf0 \

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf6 "The numbr of characters are: 
\fs36 \cf4 \\
\fs28 \cf6 (\cf10 countSymbols\cf6 )"
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 var
\fs36 \cf4  numberOfSeparators = 
\fs28 \cf10 countSymbols
\fs36 \cf4  / 
\fs28 \cf8 5
\f1\fs24 \cf0 \

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf6 "The number of spaces should be: 
\fs36 \cf4 \\
\fs28 \cf6 (\cf10 numberOfSeparators\cf6 )"
\fs36 \cf4 )
\f1\fs24 \cf0 \
\

\f0\fs28 \cf2 var
\fs36 \cf4  numberOfSymbolsBeforeFirstSeparator = 
\fs28 \cf10 countSymbols
\fs36 \cf4  - (
\fs28 \cf10 numberOfSeparators
\fs36 \cf4  * 
\fs28 \cf8 5
\fs36 \cf4 )
\f1\fs24 \cf0 \
\
\pard\tx890\pardeftab890\pardirnatural\partightenfactor0

\f0\fs28 \cf11 \cb3 //userInput.insert(";", at: userInput.index(userInput.startIndex, offsetBy: numberOfSymbolsBeforeFirstSeparator))
\f1\fs24 \cf0 \cb3 \
\
\pard\tx890\pardeftab890\pardirnatural\partightenfactor0

\f0\fs28 \cf2 for
\fs36 \cf4  \cf4 \cb3 \ulth \ulc4 i\cf4 \cb3 \ulnone  
\fs28 \cf2 in
\fs36 \cf4  
\fs28 \cf8 0
\fs36 \cf4 ..<
\fs28 \cf10 numberOfSeparators
\fs36 \cf4  \{
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf10 userInput
\fs36 \cf4 .
\fs28 \cf7 insert
\fs36 \cf4 (
\fs28 \cf6 ";"
\fs36 \cf4 , at: 
\fs28 \cf10 userInput
\fs36 \cf4 .
\fs28 \cf7 index
\fs36 \cf4 (
\fs28 \cf10 userInput
\fs36 \cf4 .
\fs28 \cf5 startIndex
\fs36 \cf4 , offsetBy: 
\fs28 \cf10 numberOfSymbolsBeforeFirstSeparator
\fs36 \cf4 ))
\f1\fs24 \cf0 \

\f0\fs36 \cf4     
\fs28 \cf10 numberOfSymbolsBeforeFirstSeparator
\fs36 \cf4  += 
\fs28 \cf8 6
\f1\fs24 \cf0 \

\f0\fs36 \cf4 \}
\f1\fs24 \cf0 \
\

\f0\fs28 \cf7 print
\fs36 \cf4 (
\fs28 \cf6 "The result is: 
\fs36 \cf4 \\
\fs28 \cf6 (\cf10 userInput\cf6 )"
\fs36 \cf4 )
\f1\fs24 \cf0 \

\f0\fs36 \cf4 \
\
\
\
\
\
\
\
\

\f1\fs24 \cf0 \
}